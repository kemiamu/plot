<!doctype html>
<html lang="en" x-data="app()">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Scatter Plot Visualization</title>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css" />
    <style>
      canvas {
        border: 1px solid #dbdbdb;
        background-color: #f8f8f8;
      }
    </style>

    <script>
      function app() {
        return {
          status: "loading",
          ctx: null,

          // Constants
          CANVAS_SIZE: 1024,
          CANVAS_BACKGROUND_COLOR: "#f8f8f8",
          POINT_RADIUS: 5,
          POINT_FILL_COLOR: "#888",
          LABEL_FONT: "14px Arial",
          LABEL_COLOR: "#111",
          LABEL_OFFSET: 14,
          PROPORTION: 0.9,
          SAMPLE_DATA_RANGE: 100,

          // points
          _pointGroups: [],

          get pointGroups() {
            return this._pointGroups;
          },

          set pointGroups(value) {
            // shallow copy
            const points = value.flat();
            const range = points.length - 1;

            const cols = points.sort((a, b) => a.x - b.x);
            cols.forEach((item, index) => (item.rank_x = index / range));
            const rows = points.sort((a, b) => a.y - b.y);
            rows.forEach((item, index) => (item.rank_y = index / range));

            // tools

            const margin = (1 - this.PROPORTION) / 2;
            const convert_to_canvas = (point) => [
              (margin + this.PROPORTION * point[0]) * this.CANVAS_SIZE,
              (margin + this.PROPORTION * point[1]) * this.CANVAS_SIZE,
            ];

            const draw_point = (point, location, name) => {
              const [canvas_x, canvas_y] = convert_to_canvas(point);

              this.ctx.beginPath();
              this.ctx.arc(canvas_x, canvas_y, this.POINT_RADIUS, 0, Math.PI * 2);
              this.ctx.fillStyle = this.POINT_FILL_COLOR;
              this.ctx.fill();

              const draw_label = (text, offset_level) => {
                const offset = this.POINT_RADIUS * 2 + this.LABEL_OFFSET * offset_level;
                this.ctx.font = this.LABEL_FONT;
                this.ctx.fillStyle = this.LABEL_COLOR;
                this.ctx.textAlign = "center";
                this.ctx.fillText(text, canvas_x, canvas_y - offset);
              };

              draw_label(`(${location[0].toFixed(2)}, ${location[1].toFixed(2)})`, 0);
              draw_label(name, 1);
            };

            const draw_line = (p0, p1, style, width) => {
              const [x0, y0] = convert_to_canvas(p0);
              const [x1, y1] = convert_to_canvas(p1);

              this.ctx.beginPath();
              this.ctx.strokeStyle = style;
              this.ctx.lineWidth = width;
              this.ctx.moveTo(x0, y0);
              this.ctx.lineTo(x1, y1);
              this.ctx.stroke();
            };

            const draw_trunk = (p0, p1) => {
              const direction = Math.abs(p0[0] - p1[0]) >= Math.abs(p0[1] - p1[1]);
              return draw_line(p0, p1, direction ? "#ff0000" : "#0000ff", 1);
            };

            const draw_branch = (p0, p1) => draw_line(p0, p1, "#00aa00", 1);

            // draws

            this.ctx.clearRect(0, 0, this.CANVAS_SIZE, this.CANVAS_SIZE);
            this.ctx.fillStyle = this.CANVAS_BACKGROUND_COLOR;
            this.ctx.fillRect(0, 0, this.CANVAS_SIZE, this.CANVAS_SIZE);

            // lines
            value.map((points) => {
              if (points.length < 2) return [];

              const main_point = points[0];
              let trunk_x = { min: main_point.rank_x, max: main_point.rank_x };
              let trunk_y = { min: main_point.rank_y, max: main_point.rank_y };

              // Draw branches and collect trunk extents
              points.forEach((point) => {
                if (Math.abs(point.x - main_point.x) >= Math.abs(point.y - main_point.y)) {
                  trunk_x.min = Math.min(trunk_x.min, point.rank_x);
                  trunk_x.max = Math.max(trunk_x.max, point.rank_x);
                  draw_branch([point.rank_x, main_point.rank_y], [point.rank_x, point.rank_y]);
                } else {
                  trunk_y.min = Math.min(trunk_y.min, point.rank_y);
                  trunk_y.max = Math.max(trunk_y.max, point.rank_y);
                  draw_branch([main_point.rank_x, point.rank_y], [point.rank_x, point.rank_y]);
                }
              });

              // Draw trunk line
              draw_trunk([trunk_x.min, main_point.rank_y], [trunk_x.max, main_point.rank_y]);
              draw_trunk([main_point.rank_x, trunk_y.min], [main_point.rank_x, trunk_y.max]);

              return points;
            });

            // Draw points
            points.forEach((point) => {
              // Skip drawing if point has no name
              if (!point.name) return;
              draw_point([point.rank_x, point.rank_y], [point.x, point.y], point.name);
            });

            // set value
            console.log("Setting points:", value);
            this._pointGroups = value;
          },

          // Computed properties
          get xRange() {
            const points = this.pointGroups.flat();
            if (!points.length) return "N/A";
            const xs = points.map((p) => p.x);
            return `${Math.min(...xs).toFixed(2)} to ${Math.max(...xs).toFixed(2)}`;
          },

          get yRange() {
            const points = this.pointGroups.flat();
            if (!points.length) return "N/A";
            const ys = points.map((p) => p.y);
            return `${Math.min(...ys).toFixed(2)} to ${Math.max(...ys).toFixed(2)}`;
          },

          // init
          init() {
            this.ctx = this.$refs.canvas.getContext("2d");
            this.fetchData();
          },

          // Fetch data from points.json
          fetchData() {
            this.status = "loading";

            fetch("./points.json")
              .then((resp) => resp.json())
              .then((data) => {
                this.pointGroups = data;
                this.status = "finish";
              })
              .catch((err) => {
                console.error("Error loading points.json:", err);
                this.loadSampleData();
                this.status = "error";
              });
          },

          // Refresh data
          refreshData() {
            this.fetchData();
          },

          // Load sample data (fallback)
          loadSampleData() {
            // Generate sample data if points.json is not found
            const names = [
              "Home",
              "Work",
              "School",
              "Park",
              "Mall",
              "Hospital",
              "Airport",
              "Station",
              "Library",
              "Gym",
              "Restaurant",
              "Cafe",
              "Supermarket",
              "Bank",
              "Post Office",
              "Hotel",
              "Museum",
              "Theater",
              "Cinema",
              "Stadium",
              "University",
              "College",
              "Pharmacy",
              "Clinic",
              "Police Station",
              "Fire Station",
              "Gas Station",
              "Car Wash",
              "Hardware Store",
              "Bookstore",
              "Electronics Store",
              "Clothing Store",
              "Shoe Store",
              "Toy Store",
              "Pet Store",
              "Florist",
              "Bakery",
              "Butcher",
              "Farmers Market",
              "Convenience Store",
              "Department Store",
              "Outlet",
              "Beach",
              "Lake",
              "Mountain",
              "Forest",
              "Zoo",
              "Aquarium",
              "Amusement Park",
              "Gallery",
              null,
              null,
              null,
              null,
              null,
              null,
              null,
              null,
              null,
              null,
            ];
            const points = names.map((name) => ({
              x: (Math.random() - 0.5) * this.SAMPLE_DATA_RANGE * 2,
              y: (Math.random() - 0.5) * this.SAMPLE_DATA_RANGE * 2,
              name,
            }));

            console.log("Parsed points:", points);
            this.pointGroups = [points];
          },
        };
      }
    </script>
  </head>
  <body>
    <section class="section">
      <div class="container">
        <div class="columns">
          <div class="column is-8">
            <div class="level is-mobile">
              <div class="level-left">
                <div class="level-item">
                  <h1 class="title is-4">Scatter Plot</h1>
                </div>
              </div>
              <div class="level-right">
                <div class="level-item">
                  <button class="button is-small is-primary" @click="refreshData">Refresh</button>
                </div>
              </div>
            </div>

            <template x-if="status === 'error'">
              <div class="notification is-danger">Failed to load data. Displaying random data.</div>
            </template>
            <div class="notification" x-show="status === 'loading'" x-transition>Loading...</div>

            <canvas
              :width="CANVAS_SIZE"
              :height="CANVAS_SIZE"
              x-ref="canvas"
              style="max-width: 100%; height: auto"
            ></canvas>
          </div>

          <div class="column is-4">
            <div class="notification">
              <p><strong>Total Points:</strong> <span x-text="pointGroups.flat().length"></span></p>
              <p><strong>X Range:</strong> <span x-text="xRange"></span></p>
              <p><strong>Y Range:</strong> <span x-text="yRange"></span></p>
            </div>

            <template x-if="pointGroups.flat().length > 0">
              <table class="table is-fullwidth">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>X</th>
                    <th>Y</th>
                  </tr>
                </thead>
                <tbody>
                  <template x-for="point in pointGroups.flat().filter((p)=>p.name)">
                    <tr>
                      <td x-text="point.name"></td>
                      <td x-text="point.x.toFixed(2)"></td>
                      <td x-text="point.y.toFixed(2)"></td>
                    </tr>
                  </template>
                </tbody>
              </table>
            </template>
          </div>
        </div>
      </div>
    </section>
  </body>
</html>
