<!doctype html>
<html lang="en" x-data="app()">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Scatter Plot Visualization</title>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css" />
    <style>
      canvas {
        border: 1px solid #dbdbdb;
        background-color: #f8f8f8;
      }
    </style>

    <script>
      // Constants
      const CANVAS_SIZE = 1024;
      const CANVAS_BACKGROUND_COLOR = "#f8f8f8";
      const POINT_RADIUS = 5;
      const POINT_FILL_COLOR = "#888";
      const LABEL_FONT = "16px Arial";
      const LABEL_COLOR = "#111";
      const LABEL_OFFSET = 16;
      const PROPORTION = 0.815;
      const SAMPLE_DATA_RANGE = 100;
      const TRUNK_COLOR_X = "#ff0000";
      const TRUNK_COLOR_Y = "#0000ff";
      const BRANCH_COLOR = "#00aa00";
      const LINE_WIDTH = 1;
      const NAMES = [
        "Home",
        "Work",
        "School",
        "Park",
        "Mall",
        "Hospital",
        "Airport",
        "Station",
        "Library",
        "Gym",
        "Restaurant",
        "Cafe",
        "Supermarket",
        "Bank",
        "Post Office",
        "Hotel",
        "Museum",
        "Theater",
        "Cinema",
        "Stadium",
        "University",
        "College",
        "Pharmacy",
        "Clinic",
        "Police Station",
        "Fire Station",
        "Gas Station",
        "Car Wash",
        "Hardware Store",
        "Bookstore",
        "Electronics Store",
        "Clothing Store",
        "Shoe Store",
        "Toy Store",
        "Pet Store",
        "Florist",
        "Bakery",
        "Butcher",
        "Farmers Market",
        "Convenience Store",
        "Department Store",
        "Outlet",
        "Beach",
        "Lake",
        "Mountain",
        "Forest",
        "Zoo",
        "Aquarium",
        "Amusement Park",
        "Gallery",
      ];

      function app() {
        return {
          status: "loading",
          ctx: null,

          // points
          _pointGroups: [],

          get pointGroups() {
            return this._pointGroups;
          },

          set pointGroups(value) {
            const points = value.flat();
            const range = points.length - 1;

            const cols = points.sort((a, b) => a.x - b.x);
            cols.forEach((item, index) => (item.rank_x = index / range));
            const rows = points.sort((a, b) => a.y - b.y);
            rows.forEach((item, index) => (item.rank_y = index / range));

            // render
            this.renderPoints(value, points);

            // set value
            console.log("Setting points:", value);
            this._pointGroups = value;
          },

          // render
          renderPoints(groups, allPoints) {
            // tools
            const margin = (1 - PROPORTION) / 2;
            const convert_to_canvas = (point) => [
              (margin + PROPORTION * point[0]) * CANVAS_SIZE,
              (margin + PROPORTION * point[1]) * CANVAS_SIZE,
            ];

            const draw_point = (point, location, name) => {
              const [canvas_x, canvas_y] = convert_to_canvas(point);

              this.ctx.beginPath();
              this.ctx.arc(canvas_x, canvas_y, POINT_RADIUS, 0, Math.PI * 2);
              this.ctx.fillStyle = POINT_FILL_COLOR;
              this.ctx.fill();

              const draw_label = (text, offset_level) => {
                const offset = POINT_RADIUS * 2 + LABEL_OFFSET * offset_level;
                this.ctx.font = LABEL_FONT;
                this.ctx.fillStyle = LABEL_COLOR;
                this.ctx.textAlign = "center";
                this.ctx.fillText(text, canvas_x, canvas_y - offset);
              };

              draw_label(`(${location[0].toFixed(2)}, ${location[1].toFixed(2)})`, 0);
              draw_label(name, 1);
            };

            const draw_line = (p0, p1, style, width) => {
              const [x0, y0] = convert_to_canvas(p0);
              const [x1, y1] = convert_to_canvas(p1);

              this.ctx.beginPath();
              this.ctx.strokeStyle = style;
              this.ctx.lineWidth = width;
              this.ctx.moveTo(x0, y0);
              this.ctx.lineTo(x1, y1);
              this.ctx.stroke();
            };

            const draw_trunk = (p0, p1) => {
              const direction = Math.abs(p0[0] - p1[0]) >= Math.abs(p0[1] - p1[1]);
              return draw_line(p0, p1, direction ? TRUNK_COLOR_X : TRUNK_COLOR_Y, LINE_WIDTH);
            };

            const draw_branch = (p0, p1) => draw_line(p0, p1, BRANCH_COLOR, LINE_WIDTH);

            // draws

            this.ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            this.ctx.fillStyle = CANVAS_BACKGROUND_COLOR;
            this.ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // lines
            groups.map((points) => {
              if (points.length < 2) return [];

              const main_point = points[0];
              let trunk_x = { min: main_point.rank_x, max: main_point.rank_x };
              let trunk_y = { min: main_point.rank_y, max: main_point.rank_y };

              // Draw branches and collect trunk extents
              points.forEach((point) => {
                if (Math.abs(point.x - main_point.x) >= Math.abs(point.y - main_point.y)) {
                  trunk_x.min = Math.min(trunk_x.min, point.rank_x);
                  trunk_x.max = Math.max(trunk_x.max, point.rank_x);
                  draw_branch([point.rank_x, main_point.rank_y], [point.rank_x, point.rank_y]);
                } else {
                  trunk_y.min = Math.min(trunk_y.min, point.rank_y);
                  trunk_y.max = Math.max(trunk_y.max, point.rank_y);
                  draw_branch([main_point.rank_x, point.rank_y], [point.rank_x, point.rank_y]);
                }
              });

              // Draw trunk line
              draw_trunk([trunk_x.min, main_point.rank_y], [trunk_x.max, main_point.rank_y]);
              draw_trunk([main_point.rank_x, trunk_y.min], [main_point.rank_x, trunk_y.max]);

              return points;
            });

            // Draw points
            allPoints.forEach((point) => {
              // Skip drawing if point has no name
              if (!point.name) return;
              draw_point([point.rank_x, point.rank_y], [point.x, point.y], point.name);
            });
          },

          // Computed properties
          getRange(property) {
            const points = this.pointGroups.flat();
            if (!points.length) return "N/A";
            const min = Math.min(...points.map((p) => p[property]));
            const max = Math.max(...points.map((p) => p[property]));
            return `${min.toFixed(2)} to ${max.toFixed(2)}`;
          },

          get xRange() {
            return this.getRange("x");
          },

          get yRange() {
            return this.getRange("y");
          },

          // init
          init() {
            this.ctx = this.$refs.canvas.getContext("2d");
            this.fetchData();
          },

          // Fetch data from points.json
          fetchData() {
            this.status = "loading";

            fetch("./points.json", {
                cache: 'reload'
            })
              .then((resp) => resp.json())
              .then((data) => {
                this.pointGroups = data;
                this.status = "finish";
              })
              .catch((err) => {
                console.error("Error loading points.json:", err);
                this.loadSampleData();
                this.status = "error";
              });
          },

          // Refresh data
          refreshData() {
            this.fetchData();
          },

          // Load sample data (fallback)
          loadSampleData() {
            // Generate sample data if points.json is not found
            const points = NAMES.map((name, index) => {
              const range = SAMPLE_DATA_RANGE * ((index + 1) / NAMES.length);
              return {
                x: (Math.random() - 0.5) * range,
                y: (Math.random() - 0.5) * range,
                name,
              };
            });

            this.pointGroups = [points];
          },
        };
      }
    </script>
  </head>
  <body>
    <section class="section">
      <div class="container is-max-widescreen">
        <div class="columns">
          <div class="column is-8">
            <div class="level is-mobile">
              <div class="level-left">
                <div class="level-item">
                  <h1 class="title is-4">Scatter Plot</h1>
                </div>
              </div>
              <div class="level-right">
                <div class="level-item">
                  <button class="button is-small is-primary" @click="refreshData">Refresh</button>
                </div>
              </div>
            </div>

            <template x-if="status === 'error'">
              <div class="notification is-danger">Failed to load data. Displaying random data.</div>
            </template>
            <div class="notification" x-show="status === 'loading'">Loading...</div>

            <canvas
              :width="CANVAS_SIZE"
              :height="CANVAS_SIZE"
              x-ref="canvas"
              style="max-width: 100%; height: auto"
            ></canvas>
          </div>

          <div class="column is-4">
            <div class="notification">
              <p><strong>Total Points:</strong> <span x-text="pointGroups.flat().length"></span></p>
              <p><strong>X Range:</strong> <span x-text="xRange"></span></p>
              <p><strong>Y Range:</strong> <span x-text="yRange"></span></p>
            </div>

            <template x-if="pointGroups.flat().length > 0">
              <table class="table is-fullwidth">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>X</th>
                    <th>Y</th>
                  </tr>
                </thead>
                <tbody>
                  <template x-for="point in pointGroups.flat().filter((p)=>p.name)">
                    <tr>
                      <td x-text="point.name"></td>
                      <td x-text="point.x.toFixed(2)"></td>
                      <td x-text="point.y.toFixed(2)"></td>
                    </tr>
                  </template>
                </tbody>
              </table>
            </template>
          </div>
        </div>
      </div>
    </section>
  </body>
</html>
